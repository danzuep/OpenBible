@page "/{language}/{version}/{book}/{chapter:int}/stream"
@using System.Collections.Concurrent
@using Bible.Core.Models
@using Bible.Core.Models.Scripture
@using Bible.ServiceDefaults.Models
@rendermode InteractiveServer

@inject BackendApiClient BackendApi

@if (scriptureRange == null)
{
    <p>Loading scripture...</p>
}
else if (scriptureRange.ScriptureRecords == null || !scriptureRange.ScriptureRecords.Any())
{
    <h5>@scriptureRange?.BookMetadata?.Version</h5>
    <h3>@scriptureRange?.BookMetadata?.Name</h3>

    <label>
        <input type="checkbox" @bind="loadPronunciation" /> Load Pronunciation
    </label>

    <p>Loading scripture content...</p>
}
else
{
    <p>
        @foreach (var fragment in GetRenderFragments())
        {
            @fragment
        }
    </p>
}

@code {
    [Parameter] public string? language { get; set; }
    [Parameter] public string? version { get; set; }
    [Parameter] public string? book { get; set; }
    [Parameter] public int chapter { get; set; }

    private ScriptureRange scriptureRange = new();

    // Optional pronunciation records, keyed by a unique ID or index
    // Assuming ScriptureRecord has an ID or we can match by position
    private Dictionary<int, ScriptureSegmentDto> runeMetadata = new();

    private bool loadPronunciation;

    protected override async Task OnParametersSetAsync()
    {
        scriptureRange.ScriptureRecords = new List<ScriptureSegmentDto>();
        runeMetadata.Clear();

        await LoadScriptureRecordsAsync();

        if (loadPronunciation)
        {
            await GetRuneMetadataAsync();
        }
    }

    private async Task OnPronunciationChanged(ChangeEventArgs e)
    {
        if (!runeMetadata.Any() && e.Value is bool loadPronunciation && loadPronunciation)
        {
            await GetRuneMetadataAsync();
            StateHasChanged();
        }
    }

    private async Task LoadScriptureRecordsAsync()
    {
        // Stream ScriptureRecords from backend
        await foreach (var record in BackendApi.GetScriptureRecordsStreamAsync(language, version, book, chapter))
        {
            if (record.BookMetadata != null)
            {
                scriptureRange.BookMetadata = record.BookMetadata;
            }
            scriptureRange.ScriptureRecords!.Add(record);
            // Request UI update for streamed data
            StateHasChanged();
        }
    }

    private async Task GetRuneMetadataAsync()
    {
        // Stream pronunciation data separately
        // Assume BackendApi has method GetPronunciationRecordsStreamAsync returning IAsyncEnumerable<ScriptureRecord>
        // We'll match pronunciation to text by index or ID; here we assume index for demo

        // Clear any existing pronunciation data
        runeMetadata.Clear();

        int idx = 0;
        await foreach (var pronunciationRecord in BackendApi.GetRuneMetadataStreamAsync(language, version, book, chapter))
        {
            // Store pronunciation by index or ID, here by index
            runeMetadata[idx] = pronunciationRecord;
            idx++;

            StateHasChanged();
        }
    }

    /// <summary>
    /// Enumerates RenderFragments by pairing Text + Pronunciation segments together.
    /// Uses separate pronunciation dictionary if enabled.
    /// </summary>
    private IEnumerable<RenderFragment> GetRenderFragments()
    {
        var segments = scriptureRange.ScriptureRecords;
        for (int i = 0; i < segments.Count; i++)
        {
            var segment = segments[i];

            if (loadPronunciation && segment.Category == MetadataCategory.Text)
            {
                // Try to get matching pronunciation if available
                runeMetadata.TryGetValue(i, out var pronunciation);

                if (pronunciation != null && pronunciation.Category == MetadataCategory.Pronunciation)
                {
                    yield return RenderSegment(segment, pronunciation);
                    continue; // Skip the rest of the loop to avoid double rendering
                }
            }

            // If not Text, or no pronunciation, render normally
            if (segment.Category != MetadataCategory.Pronunciation)
            {
                yield return RenderSegment(segment);
            }
        }
    }

    private RenderFragment RenderSegment(ScriptureSegmentDto segment, ScriptureSegmentDto? pronunciationSegment = null) => builder =>
    {
        switch (segment.Category)
        {
            case MetadataCategory.Text when pronunciationSegment != null:
                builder.OpenElement(0, "ruby");
                builder.AddContent(1, segment.Text);
                builder.OpenElement(2, "rt");
                builder.AddContent(3, pronunciationSegment.Text);
                builder.CloseElement();
                builder.CloseElement();
                break;

            case MetadataCategory.Text:
                builder.AddContent(0, segment.Text);
                break;

            case MetadataCategory.Pronunciation:
                // Pronunciation handled separately, skip standalone here
                break;

            case MetadataCategory.Chapter:
                builder.OpenElement(0, "h4");
                builder.AddContent(1, segment.Text);
                builder.CloseElement();
                break;

            case MetadataCategory.Verse:
                builder.OpenElement(0, "sup");
                builder.AddContent(1, segment.Text);
                builder.CloseElement();
                break;

            case MetadataCategory.Style:
                if (segment.Text.Equals("p"))
                {
                    builder.OpenElement(0, "br");
                    builder.CloseElement();
                }
                break;

            case MetadataCategory.Footnote:
                builder.OpenElement(0, "sup");
                builder.AddContent(1, segment.Text);
                builder.CloseElement();
                break;

            default:
                // Skip unknown categories
                break;
        }
    };
}