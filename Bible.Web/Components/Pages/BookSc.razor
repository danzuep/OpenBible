@page "/{language}/{version}/{book}/{chapter:int}"
@using Bible.Core.Models
@using Bible.Core.Models.Scripture
@using Bible.ServiceDefaults.Models
@using System.Diagnostics.CodeAnalysis
@rendermode InteractiveServer

@inject BackendApiClient BackendApi

@if (scriptureRange == null)
{
    <p>Loading Scripture book chapter...</p>
}
else
{
    <h5>@scriptureRange.BookMetadata?.Version</h5>
    <h3>@scriptureRange.BookMetadata?.Name</h3>

    <p>
        @foreach (var fragment in GetRenderFragments())
        {
            @fragment
        }
    </p>
}

@code {
    [Parameter] public string? language { get; set; }
    [Parameter] public string? version { get; set; }
    [Parameter] public string? book { get; set; }
    [Parameter] public int chapter { get; set; }

    private ScriptureRange? scriptureRange;

    protected override async Task OnParametersSetAsync()
    {
        scriptureRange = await BackendApi.GetScriptureBookChapterAsync(language, version, book, chapter);
    }

    /// <summary>
    /// Enumerates RenderFragments by pairing Text + Pronunciation segments together.
    /// </summary>
    private IEnumerable<RenderFragment> GetRenderFragments()
    {
        var segments = scriptureRange?.ScriptureRecords ?? new List<ScriptureSegmentDto>();
        for (int i = 0; i < segments.Count; i++)
        {
            var segment = segments[i];

            // If this is a Text segment and next segment is a Pronunciation, pair them
            if (segment.Category == MetadataCategory.Pronunciation && i + 1 < segments.Count &&
                segments[i + 1].Category == MetadataCategory.Text)
            {
                yield return RenderSegment(segments[i + 1], segment);
                i++; // Skip the pronunciation segment as it's processed
            }
            else if (segment.Category != MetadataCategory.Pronunciation)
            {
                // Render other segments normally, skip standalone Pronunciation segments
                yield return RenderSegment(segment);
            }
        }
    }

    private RenderFragment RenderSegment(ScriptureSegmentDto segment, ScriptureSegmentDto? nextSegment = null) => builder =>
    {
        switch (segment.Category)
        {
            case MetadataCategory.Text when nextSegment?.Category == MetadataCategory.Pronunciation:
                builder.OpenElement(0, "ruby");
                builder.AddContent(1, segment.Text);
                builder.OpenElement(2, "rt");
                builder.AddContent(3, nextSegment.Text);
                builder.CloseElement();
                builder.CloseElement();
                break;

            case MetadataCategory.Text:
                builder.AddContent(0, segment.Text);
                break;

            case MetadataCategory.Pronunciation:
                // Already rendered with matching Text segment, so skip standalone pronunciation
                break;

            case MetadataCategory.Chapter:
                builder.OpenElement(0, "h4");
                builder.AddContent(1, segment.Text);
                builder.CloseElement();
                break;

            case MetadataCategory.Verse:
                builder.OpenElement(0, "sup");
                builder.AddContent(1, segment.Text);
                builder.CloseElement();
                break;

            case MetadataCategory.Style:
                if (segment.Text.Equals("p"))
                {
                    builder.OpenElement(0, "br");
                    builder.CloseElement();
                }
                break;

            case MetadataCategory.Footnote:
                builder.OpenElement(0, "sup");
                builder.AddContent(1, segment.Text);
                builder.CloseElement();
                break;

            default:
                // Skip unknown categories
                break;
        }
    };
}